#include <iostream>
#include <cmath>
using namespace std;

void fact() // функция факторизации числа (почитать лекцию 4, слайды 28 - 33)
{
	int N; // наше вводимое число
	int div = 2; // наш делитель
	cout << "Enter Number:";
	cin >> N;
	cout << N << " = 1"; // пишем единицу, так как любое число можно умножить на один и эта единичка будет одним из множителей)
	while (N > 1) 
	{
		while (N % div == 0) // пока остаток от деления равен нулю, выполняем условие
		{
			cout << " * " << div; // выписываем наш делитель
			N = N / div; // изменяем наше число, так как мы его факторизируем и надо уменьшать
		}
		div++; // увеличиваем делитель на единицу каждый раз, пока наше N больше одного
	}
	// Пример. Вводим число 125. Выписывается сразу единица как множитель. Итак, 125%2 = 1. Ничего не выписываем, делаем делитель трём. 125%3 = тоже точно не ноль.
	// От четырёх остаток не ноль тоже. Берём 5. 125%5 = 0. Выписываем наш делитель 5. Уменьшаем N. 125/5 = 25. Сбрасываем делитель, теперь он снова равен двум.
	// Повторяем всё заново, только с N = 25. Действия повторяются, пока N больше одного.
	cout << " " << endl;
}
int nod(int a, int b) // алгоритм нахождения НОД (алгоритм Эвклида)
{
	if (b == 0) return a; // если у нас одно число - ноль, а второе - любое число, отличное от ноля, то НОД = тому числу, которое не ноль
	return nod(b, a % b); // в любых других случаях мы находим остаток от деления от меньшего до большего числа. Пример. Ввели два числа - 125 и 25.
	                      // находим остаток от деления 25%125. Всё.
}

int nok(int t, int q) // алгоритм нахождения НОК
{
	return q * t / nod(t, q); // НОК находим по формуле (лекция 4, слайд 58)
}

int main()
{
	int choice;
	int n, i; // переменные для проверки числа на простоту (выбран первый вариант в меню)
	int f, s; // переменные для НОК и НОД (выбран третий вариант в меню)
	bool isPrime; // простое ли число?

	while (1)
	{
		cout << " " << endl;
		cout << "1) Check Number " << endl;
		cout << "2) Factorise Number " << endl;
		cout << "3) Find NOK and NOD" << endl;
		cin >> choice;
		switch (choice)
		{
		case 1:
			cout << "Enter a number:";
			isPrime = true;
			cin >> n; // вводим число, которое хотим проверить на простоту, например, 12
			cout << n << endl;
			for (i = 2; i <= (sqrt(abs(n))); i++) // согласно правилу, число i должно быть не больше корня из нашего числа, которое проверяем на простоту
			{
				if (n%i == 0) // если остаток от деления на i равен нулю (12%2 = 0), то число не простое, и прогонять дальше цикл нет смысла
				{
					isPrime = false; // устанавливаем, что число не простое
					break; // устанавливаем цикл
				}
			}
			if (isPrime) // если же наше n делится c остатком на все целые i от 2 до корня из n, то число простое, bool IsPrime = true. 
				// Пример. Проверим 17 на простоту. Сначала i = 2. Корень из 17 = 4,1. Проверяем остаток деления. Сначала 17%2 = 1. Всё хорошо.
				// Увеличиваем i на единицу. 17%3 = 2. Далее 17%4 = 1. Итог: число простое. Метод связан с решетом Эратосфена.
			{

				cout << "This is a prime number" << endl;
			}
			else
			{
				cout << "This is not a prime number" << endl;

			}
			break;

		case 2:
			fact();
			break;

		case 3:
			cout << "Enter first Number: " << endl;
			cin >> f;
			cout << "Enter second Number: " << endl;
			cin >> s;
			cout << "NOD: " << nod(abs(f), abs(s)) << endl;
			cout << "NOK: " << nok(f, s) << endl;
			break;
		}
	}
	return (0);
}
